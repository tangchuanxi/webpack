"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = validate;

var _ast = require("@webassemblyjs/ast");

var _moduleContext = _interopRequireDefault(require("./type-checker/module-context.js"));

var _getType = _interopRequireDefault(require("./type-checker/get-type.js"));

var _types = require("./type-checker/types.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var errors = [];
var stopFuncCheck = false;

function checkTypes(a, b) {
  if (a === _types.ANY && b) {
    return;
  }

  if (b === _types.ANY && a) {
    return;
  } // the type u32 is equal to i32


  if (a === "u32") a = "i32";
  if (b === "u32") b = "i32"; // the type u64 is equal to i64

  if (a === "u64") a = "i64";
  if (b === "u64") b = "i64";

  if (a !== b) {
    errors.push("Expected type ".concat(a, " but got ").concat(b || "none", "."));
    stopFuncCheck = true;
  }
}

function validate(ast) {
  // Module context
  var moduleContext = new _moduleContext.default();

  if (!ast.body || !ast.body[0] || !ast.body[0].fields) {
    return [];
  }

  ast.body[0].fields.forEach(function (field) {
    switch (field.type) {
      case "Func":
        {
          moduleContext.addFunction(field.signature);
          break;
        }

      case "Global":
        {
          moduleContext.defineGlobal(field.globalType.valtype, field.mutability);
          break;
        }

      case "ModuleImport":
        {
          switch (field.descr.type) {
            case "GlobalType":
              {
                moduleContext.importGlobal(field.descr.valtype);
                break;
              }

            case "Memory":
              {
                moduleContext.addMemory(field.descr.limits.min, field.descr.limits.max);
                break;
              }

            case "FuncImportDescr":
              {
                moduleContext.importFunction(field.descr.signature);
                break;
              }

            case "Table":
              {
                // FIXME(sven): not implemented yet
                break;
              }

            default:
              throw new Error("Unsupported ModuleImport of type " + JSON.stringify(field.descr.type));
          }

          break;
        }

      case "Memory":
        {
          moduleContext.addMemory(field.limits.min, field.limits.max);
          break;
        }
    }
  });
  errors = []; // Simulate stack types throughout all function bodies

  (0, _ast.traverse)(ast, {
    Func: function Func(_ref) {
      var node = _ref.node;
      stopFuncCheck = false;
      var expectedResult = node.signature.results;
      moduleContext.newContext(node.name.value, expectedResult); // Parameters are local variables

      node.signature.params.forEach(function (p) {
        return moduleContext.addLocal(p.valtype);
      });
      var resultingStack = node.body.reduce(applyInstruction.bind(null, moduleContext), []);

      if (stopFuncCheck) {
        return errors;
      } // Compare the two


      checkStacks(expectedResult, resultingStack);
    }
  });
  return errors;
}

function isEmptyStack(stack) {
  // Polymorphic types are allowed in empty stack
  return stack.filter(function (t) {
    return t !== _types.POLYMORPHIC;
  }).length === 0;
}

function checkStacks(expectedStack, actualStack) {
  if (actualStack !== false) {
    var j = actualStack.length - 1;

    for (var i = 0; i < expectedStack.length; ++i) {
      var expected = expectedStack[i];
      var actual = actualStack[j];

      if (actual === _types.POLYMORPHIC || stopFuncCheck) {
        return;
      }

      checkTypes(expected, actual);
      --j;
    } // There are still types left on the resulting stack


    if (!isEmptyStack(actualStack.slice(0, j + 1))) {
      errors.push("Stack contains additional type ".concat(actualStack.slice(0, j + 1), "."));
    }
  }
}

function applyInstruction(moduleContext, stack, instruction) {
  // Return was called or a type error has occured, skip everything
  if (stack === false || stack.return) {
    return stack;
  } // Workaround for node.args which sometimes does not contain instructions (i32.const, call)


  if ((0, _ast.isInstruction)(instruction) === false) {
    return stack;
  } // Recursively evaluate all nested instructions


  if (instruction.args) {
    stack = instruction.args.reduce(applyInstruction.bind(null, moduleContext), stack);
  }

  if (instruction.instrArgs) {
    stack = instruction.instrArgs.reduce(applyInstruction.bind(null, moduleContext), stack);
  }

  if (instruction.intrs) {
    stack = instruction.intrs.reduce(applyInstruction.bind(null, moduleContext), stack);
  }

  var type = (0, _getType.default)(moduleContext, stack, instruction);

  if (type.error) {
    errors.push(type.error);
    return false;
  } // Structured control flow
  // Update context
  // Run on empty stack


  if (instruction.type === "BlockInstruction" || instruction.type === "LoopInstruction") {
    moduleContext.addLabel(type.result);
    var newStack = instruction.instr.reduce(applyInstruction.bind(null, moduleContext), []);

    if (!stopFuncCheck) {
      checkStacks(type.result, newStack);
    }

    stack = _toConsumableArray(stack).concat(_toConsumableArray(newStack));
    moduleContext.popLabel();
  } else if (instruction.type === "IfInstruction") {
    moduleContext.addLabel(type.result); // Condition can be nested as well

    if (instruction.test) {
      stack = instruction.test.reduce(applyInstruction.bind(null, moduleContext), stack);
    }

    var actual;

    for (var _i = 0; _i < type.args.length; ++_i) {
      var argType = type.args[_i];

      if (stack[stack.length - 1] === _types.POLYMORPHIC || stopFuncCheck) {
        return false;
      }

      actual = stack.pop();
      checkTypes(argType, actual);
    }

    var stackConsequent = instruction.consequent.reduce(applyInstruction.bind(null, moduleContext), []);
    var stackAlternate = instruction.alternate.reduce(applyInstruction.bind(null, moduleContext), []);
    var i = 0;
    var j = 0;
    var compareLengths = true;

    while (i < stackConsequent.length && j < stackAlternate.length) {
      if (stackConsequent[i] === _types.POLYMORPHIC || stackAlternate[j] === _types.POLYMORPHIC) {
        compareLengths = false;
        break;
      }

      checkTypes(stackConsequent[i], stackAlternate[j]);
      ++i;
      ++j;
    }

    while (compareLengths && i < stackConsequent.length) {
      if (stackConsequent[i] === _types.POLYMORPHIC) {
        compareLengths = false;
      }

      ++i;
    }

    while (compareLengths && j < stackConsequent.length) {
      if (stackConsequent[j] === _types.POLYMORPHIC) {
        compareLengths = false;
      }

      ++j;
    }

    if (compareLengths && stackConsequent.length !== stackAlternate.length) {
      errors.push("Type mismatch in if, got ".concat(stackConsequent, " and ").concat(stackAlternate));
    }

    checkStacks(type.result, stackConsequent);
    moduleContext.popLabel(); // Add to existing stack

    stack = _toConsumableArray(stack).concat(_toConsumableArray(stackConsequent));
  } else {
    var _actual;

    for (var _i2 = 0; _i2 < type.args.length; ++_i2) {
      var _argType = type.args[_i2];

      if (stack[stack.length - 1] === _types.POLYMORPHIC || stopFuncCheck) {
        return false;
      }

      _actual = stack.pop();
      checkTypes(_argType, _actual);
    }

    stack = _toConsumableArray(stack).concat(_toConsumableArray(type.result));
  }

  return stack;
}